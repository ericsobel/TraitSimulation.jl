{
    "docs": [
        {
            "location": "/", 
            "text": "TraitSimulation.jl (prototype)\n\n\nA Julia module to perform trait simulation.\n\n\n\n\nInstallation\n\n\nTraitSimulation requires Julia 0.5. To install TraitSimulation please type the following code in a Julia REPL:\n\n\nPkg.clone(\nhttps://github.com/huwenboshi/TraitSimulation.jl.git\n)\n\n\n\n\n\n\n\nUninstallation\n\n\nTo uninstall TraitSimulation please type the following code in a Julia REPL:\n\n\nPkg.rm(\nTraitSimulation\n)\n\n\n\n\n\nFor a complete uninstallation, please also remove the TraitSimulation directory in the .julia folder.\n\n\n\n\nKey Features\n\n\n\n\nSimulate trait under Generalized Linear Model (GLM) or Generalized Linear Mixed Model (GLMM)\n\n\nProvide convenient ways to specify the simulation model\n\n\n\n\nWhen simulating under the GLM, traits are sampled from\n\n\n\n\n\n\\text{Distribution}(\\text{Link}^{-1}(\\mu),\n  \\text{other distribution-specific parameters}).\n\n\n\n\n\nHere, \n\\mu = X\\beta\n is the mean parameter where \nX\n is the design matrix and $\\beta$ the fixed effects, \n\\text{Link}\n the link function, and \n\\text{Distribution}\n the response distribution. Depending on the type of distribution, different distribution-specific parameters are required. For example, simulating a normally distributed trait with identity link requires the variance parameter \n\\sigma^2\n, i.e. one samples from \nN(\\mu, \\sigma^2)\n. To simulate a Poisson distributed trait with log link function, one samples traits from \nPois(\\exp(\\mu))\n.\n\n\nSimulating under the GLMM is similar to simulating under the GLM, except that random effects are allowed in \n\\mu\n, e.g. \n\\mu = X\\beta + Z u + \\epsilon\n , in which \nu\n is the vector of random effects. Typically, \n\\mu\n is drawn from the normal distribution \nN(x\\beta, \\sum_{i=1}^k \\sigma^2_i V)\n, where \n\\sigma^2_i\n are the variance components. Correlated traits can be simulated by allowing for cross covariances.\n\n\n\n\nContact\n\n\nHuwenbo Shi\n (shihuwenbo [at] ucla [dot] edu)", 
            "title": "Introduction"
        }, 
        {
            "location": "/#traitsimulationjl-prototype", 
            "text": "A Julia module to perform trait simulation.", 
            "title": "TraitSimulation.jl (prototype)"
        }, 
        {
            "location": "/#installation", 
            "text": "TraitSimulation requires Julia 0.5. To install TraitSimulation please type the following code in a Julia REPL:  Pkg.clone( https://github.com/huwenboshi/TraitSimulation.jl.git )", 
            "title": "Installation"
        }, 
        {
            "location": "/#uninstallation", 
            "text": "To uninstall TraitSimulation please type the following code in a Julia REPL:  Pkg.rm( TraitSimulation )  For a complete uninstallation, please also remove the TraitSimulation directory in the .julia folder.", 
            "title": "Uninstallation"
        }, 
        {
            "location": "/#key-features", 
            "text": "Simulate trait under Generalized Linear Model (GLM) or Generalized Linear Mixed Model (GLMM)  Provide convenient ways to specify the simulation model   When simulating under the GLM, traits are sampled from   \n\\text{Distribution}(\\text{Link}^{-1}(\\mu),\n  \\text{other distribution-specific parameters}).   Here,  \\mu = X\\beta  is the mean parameter where  X  is the design matrix and $\\beta$ the fixed effects,  \\text{Link}  the link function, and  \\text{Distribution}  the response distribution. Depending on the type of distribution, different distribution-specific parameters are required. For example, simulating a normally distributed trait with identity link requires the variance parameter  \\sigma^2 , i.e. one samples from  N(\\mu, \\sigma^2) . To simulate a Poisson distributed trait with log link function, one samples traits from  Pois(\\exp(\\mu)) .  Simulating under the GLMM is similar to simulating under the GLM, except that random effects are allowed in  \\mu , e.g.  \\mu = X\\beta + Z u + \\epsilon  , in which  u  is the vector of random effects. Typically,  \\mu  is drawn from the normal distribution  N(x\\beta, \\sum_{i=1}^k \\sigma^2_i V) , where  \\sigma^2_i  are the variance components. Correlated traits can be simulated by allowing for cross covariances.", 
            "title": "Key Features"
        }, 
        {
            "location": "/#contact", 
            "text": "Huwenbo Shi  (shihuwenbo [at] ucla [dot] edu)", 
            "title": "Contact"
        }, 
        {
            "location": "/example/example/", 
            "text": "Getting Started\n\n\nThis section provides some examples on how to use the TraitSimulation module.\n\n\n\n\nOverview\n\n\nThe TraitSimulation module allows users to simulate phenotypes under various models, including fixed-effect, random-effect, and mixed-effect models. The simulation procedure takes a two-step approach. In the first step, the user constructs a simulation model using the \nSimulationModel\n type. In the second step, the user calls the \nsimulate\n function along with the data to generate the simulated phenotype, which is appended as a column to the input data frame.\n\n\n\n\nTest data set\n\n\n\n\nGenerate random data set\n\n\nThe following code creates a data frame containing genotype (x1, \n, x5) and phenotype (HDL and LDL) measurements for 10 individuals.\n\n\nusing\n \nDataFrames\n,\n \nDistributions\n,\n \nTraitSimulation\n\n\n(\npeople\n,\n \nsnps\n)\n \n=\n \n(\n10\n,\n \n5\n)\n\n\nsnp_data\n \n=\n \nMatrix\n{\nFloat64\n}(\npeople\n,\n \nsnps\n)\n\n\nfreq\n \n=\n \n[\n0.2\n,\n \n0.3\n,\n \n0.4\n,\n \n0.7\n,\n \n0.5\n]\n\n\nfor\n \ni\n=\n1\n:\nsnps\n\n    \nsnp_data\n[\n:\n,\ni\n]\n \n=\n \nrand\n(\nBinomial\n(\n2\n,\nfreq\n[\ni\n]),\n \npeople\n)\n\n\nend\n\n\n(\nhdl_data\n,\n \nldl_data\n)\n \n=\n \n(\nVector\n{\nFloat64\n}(\npeople\n),\n \nVector\n{\nFloat64\n}(\npeople\n))\n\n\nfor\n \ni\n=\n1\n:\npeople\n\n    \nhdl_data\n[\ni\n]\n \n=\n \nrand\n(\nUniform\n(\n20\n,\n80\n))\n\n    \nldl_data\n[\ni\n]\n \n=\n \nrand\n(\nUniform\n(\n20\n,\n80\n))\n\n\nend\n\n\ndata\n \n=\n \n[\nsnp_data\n \nhdl_data\n \nldl_data\n]\n\n\ndata\n \n=\n \nconvert\n(\nDataFrame\n,\n \ndata\n)\n\n\nnames!\n(\ndata\n,\n \n[\n:\nx1\n,\n \n:\nx2\n,\n \n:\nx3\n,\n \n:\nx4\n,\n \n:\nx5\n,\n \n:\nHDL\n,\n \n:\nLDL\n])\n\n\n\n\n\n\n\n\nLoad data from PLINK files\n\n\nTraitSimulation module can also take genotype data in PLINK format through \nSnpArrays\n. For example, the following code reads in genotype data from the PLINK files \nhapmap3.bed\n, \nhapmap3.bim\n, \nhapmap3.fam\n, which can then be directly passed to the \nsimulate\n function (see below for details).\n\n\ndata\n \n=\n \nSnpArray\n(\nhapmap3\n)\n\n\n\n\n\n\n\n\nSimulate normal response\n\n\nThe following code simulates a trait (\ny\n) with normal response (\n\\sigma = 1.0\n) using the data frame created in \nstep 1\n.\n\n\n\n\n\n\\mu = -0.2x_1 + 0.1x_2 * x_5 + 0.3\\log(\\text{HDL})\n\n\n\n\n\n\n\n\ny \\sim N(\\mu, 1.0)\n\n\n\n\n\nmodel\n \n=\n \nFixedEffectModel\n(\ny\n \n~\n \n-\n0.2\nx1\n+\n0.1\nx2\n*\nx5\n+\n0.3\nlog\n(\nHDL\n),\n \nIdentityLink\n(),\n \nNormalResponse\n(\n1.0\n))\n\n\nsimulate\n(\nmodel\n,\n \ndata\n)\n\n\n\n\n\n\n\n\nSimulate multiple traits\n\n\nThe following code simulates three traits (\ny_1, y_2, y_3\n) with normal response (\n\\sigma = 1.0\n) but different means, using the data frame created in \nstep 1\n.\n\n\nmodel\n \n=\n \nFixedEffectModel\n([\ny1\n \n~\n \n3.0\n+\n0.2\nx1\n,\n \ny2\n \n~\n \n2.0\n+\n0.1\nx3\n,\n \ny3\n \n~\n \n0.3\nx4\n+\nHDL\n],\n \nIdentityLink\n(),\n \nNormalResponse\n(\n1.0\n))\n\n\nsimulate\n(\nmodel\n,\n \ndata\n)\n\n\n\n\n\n\nThe following code simulates three traits (\ny_1, y_2, y_3\n) with different response distributions using the data frame created in \nstep 1\n.\n\n\n\n\n\n\\mu_1 = 0.2x_1 + 3.0, y_1 \\sim \\text{Bin}(100, \\mu_1)\n\n\n\n\n\n\n\n\n\\mu_2 = 0.1x_3 + 2.0, y_2 \\sim \\text{Pois}(\\mu_2)\n\n\n\n\n\n\n\n\n\\mu_3 = 0.3x_4 + \\text{HDL}, y_3 \\sim N(\\mu_3, 2.0)\n\n\n\n\n\n\u03bc\n \n=\n \n[\ny1\n \n~\n \n0.2\nx1\n+\n3.0\n,\n \ny2\n \n~\n \n0.1\nx3\n+\n2.0\n,\n \ny3\n \n~\n \n0.3\nx4\n+\nHDL\n]\n\n\nlink\n \n=\n \n[\nLogitLink\n(),\n \nLogLink\n(),\n \nIdentityLink\n()]\n\n\ndist\n \n=\n \n[\nBinomialResponse\n(\n100\n),\n \nPoissonResponse\n(),\n \nNormalResponse\n(\n2.0\n)]\n\n\nmodel\n \n=\n \nFixedEffectModel\n(\n\u03bc\n,\n \nlink\n,\n \ndist\n)\n\n\nsimulate\n(\nmodel\n,\n \ndata\n)\n\n\n\n\n\n\n\n\nSimulate random effects\n\n\nThe following code simulates a trait with Poisson response with two variance components, using the data frame created in \nstep 1\n.\n\n\n\n\n\n\\mu = (0.2x_1 + 2.0) + x u + \\epsilon, u \\sim N(0, 0.04K), \\epsilon \\sim N(0, 0.8I), y \\sim \\text{Pois}(\\mu)\n\n\n\n\n\n# a fake GRM\n\n\nK\n \n=\n \ncor\n(\nsnp_data\n)\n\n\nI\n \n=\n \neye\n(\npeople\n)\n\n\n\u03a3\n \n=\n \n[\nVarianceComponent\n(\n0.2\n,\n \nK\n),\n \nVarianceComponent\n(\n0.8\n,\n \nI\n)]\n\n\n\u03bc\n \n=\n \ny\n \n~\n \n0.2\nx1\n+\n2.0\n\n\nmodel\n \n=\n \nMixedEffectModel\n(\n\u03bc\n,\n \n\u03a3\n,\n \nLogLink\n(),\n \nPoissonResponse\n())\n\n\nsimulate\n(\nmodel\n,\n \ndata\n)\n\n\n\n\n\n\nWe also provide the \n@vc\n macro to simplify the specification of the covariances. Note, the variables K and I must be defined before calling the \n@vc\n macro.\n\n\n\u03a3\n \n=\n \n@vc\n \n0.2\nK\n \n+\n \n0.8\nI\n\n\nmodel\n \n=\n \nMixedEffectModel\n(\n\u03bc\n,\n \n\u03a3\n,\n \nLogLink\n(),\n \nPoissonResponse\n())\n\n\nsimulate\n(\nmodel\n,\n \ndata\n)\n\n\n\n\n\n\nThe following code snippet simulates two traits where the random effects have cross covariances.\n\n\n# a fake GRM\n\n\nK\n \n=\n \ncor\n(\ndata\n)\n\n\nI\n \n=\n \neye\n(\nnpeople\n)\n\n\nA\n \n=\n \n[\n0.2\n \n-\n0.1\n;\n \n-\n0.1\n \n0.3\n]\n\n\nB\n \n=\n \n[\n0.8\n \n-\n0.2\n;\n \n-\n0.2\n \n0.7\n]\n\n\n\u03bc\n \n=\n \n[\ny1\n \n~\n \nx1\n+\n0.2\n,\n \ny2\n \n~\n \nx3\n+\n0.1\nlog\n(\nHDL\n)\n+\n0.1\n]\n\n\nmodel\n \n=\n \nMixedEffectModel\n(\n\u03bc\n,\n \n(\n@vc\n \nA\n \n\u2297\n \nK\n \n+\n \nB\n \n\u2297\n \nI\n),\n \nIdentityLink\n(),\n \nNormalResponse\n(\n1.0\n))\n\n\nsimulate\n(\nmodel\n,\n \ndata\n)", 
            "title": "Getting Started"
        }, 
        {
            "location": "/example/example/#getting-started", 
            "text": "This section provides some examples on how to use the TraitSimulation module.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/example/example/#overview", 
            "text": "The TraitSimulation module allows users to simulate phenotypes under various models, including fixed-effect, random-effect, and mixed-effect models. The simulation procedure takes a two-step approach. In the first step, the user constructs a simulation model using the  SimulationModel  type. In the second step, the user calls the  simulate  function along with the data to generate the simulated phenotype, which is appended as a column to the input data frame.", 
            "title": "Overview"
        }, 
        {
            "location": "/example/example/#test-data-set", 
            "text": "", 
            "title": "Test data set"
        }, 
        {
            "location": "/example/example/#generate-random-data-set", 
            "text": "The following code creates a data frame containing genotype (x1,  , x5) and phenotype (HDL and LDL) measurements for 10 individuals.  using   DataFrames ,   Distributions ,   TraitSimulation  ( people ,   snps )   =   ( 10 ,   5 )  snp_data   =   Matrix { Float64 }( people ,   snps )  freq   =   [ 0.2 ,   0.3 ,   0.4 ,   0.7 ,   0.5 ]  for   i = 1 : snps \n     snp_data [ : , i ]   =   rand ( Binomial ( 2 , freq [ i ]),   people )  end  ( hdl_data ,   ldl_data )   =   ( Vector { Float64 }( people ),   Vector { Float64 }( people ))  for   i = 1 : people \n     hdl_data [ i ]   =   rand ( Uniform ( 20 , 80 )) \n     ldl_data [ i ]   =   rand ( Uniform ( 20 , 80 ))  end  data   =   [ snp_data   hdl_data   ldl_data ]  data   =   convert ( DataFrame ,   data )  names! ( data ,   [ : x1 ,   : x2 ,   : x3 ,   : x4 ,   : x5 ,   : HDL ,   : LDL ])", 
            "title": "Generate random data set"
        }, 
        {
            "location": "/example/example/#load-data-from-plink-files", 
            "text": "TraitSimulation module can also take genotype data in PLINK format through  SnpArrays . For example, the following code reads in genotype data from the PLINK files  hapmap3.bed ,  hapmap3.bim ,  hapmap3.fam , which can then be directly passed to the  simulate  function (see below for details).  data   =   SnpArray ( hapmap3 )", 
            "title": "Load data from PLINK files"
        }, 
        {
            "location": "/example/example/#simulate-normal-response", 
            "text": "The following code simulates a trait ( y ) with normal response ( \\sigma = 1.0 ) using the data frame created in  step 1 .   \n\\mu = -0.2x_1 + 0.1x_2 * x_5 + 0.3\\log(\\text{HDL})    \ny \\sim N(\\mu, 1.0)   model   =   FixedEffectModel ( y   ~   - 0.2 x1 + 0.1 x2 * x5 + 0.3 log ( HDL ),   IdentityLink (),   NormalResponse ( 1.0 ))  simulate ( model ,   data )", 
            "title": "Simulate normal response"
        }, 
        {
            "location": "/example/example/#simulate-multiple-traits", 
            "text": "The following code simulates three traits ( y_1, y_2, y_3 ) with normal response ( \\sigma = 1.0 ) but different means, using the data frame created in  step 1 .  model   =   FixedEffectModel ([ y1   ~   3.0 + 0.2 x1 ,   y2   ~   2.0 + 0.1 x3 ,   y3   ~   0.3 x4 + HDL ],   IdentityLink (),   NormalResponse ( 1.0 ))  simulate ( model ,   data )   The following code simulates three traits ( y_1, y_2, y_3 ) with different response distributions using the data frame created in  step 1 .   \n\\mu_1 = 0.2x_1 + 3.0, y_1 \\sim \\text{Bin}(100, \\mu_1)    \n\\mu_2 = 0.1x_3 + 2.0, y_2 \\sim \\text{Pois}(\\mu_2)    \n\\mu_3 = 0.3x_4 + \\text{HDL}, y_3 \\sim N(\\mu_3, 2.0)   \u03bc   =   [ y1   ~   0.2 x1 + 3.0 ,   y2   ~   0.1 x3 + 2.0 ,   y3   ~   0.3 x4 + HDL ]  link   =   [ LogitLink (),   LogLink (),   IdentityLink ()]  dist   =   [ BinomialResponse ( 100 ),   PoissonResponse (),   NormalResponse ( 2.0 )]  model   =   FixedEffectModel ( \u03bc ,   link ,   dist )  simulate ( model ,   data )", 
            "title": "Simulate multiple traits"
        }, 
        {
            "location": "/example/example/#simulate-random-effects", 
            "text": "The following code simulates a trait with Poisson response with two variance components, using the data frame created in  step 1 .   \n\\mu = (0.2x_1 + 2.0) + x u + \\epsilon, u \\sim N(0, 0.04K), \\epsilon \\sim N(0, 0.8I), y \\sim \\text{Pois}(\\mu)   # a fake GRM  K   =   cor ( snp_data )  I   =   eye ( people )  \u03a3   =   [ VarianceComponent ( 0.2 ,   K ),   VarianceComponent ( 0.8 ,   I )]  \u03bc   =   y   ~   0.2 x1 + 2.0  model   =   MixedEffectModel ( \u03bc ,   \u03a3 ,   LogLink (),   PoissonResponse ())  simulate ( model ,   data )   We also provide the  @vc  macro to simplify the specification of the covariances. Note, the variables K and I must be defined before calling the  @vc  macro.  \u03a3   =   @vc   0.2 K   +   0.8 I  model   =   MixedEffectModel ( \u03bc ,   \u03a3 ,   LogLink (),   PoissonResponse ())  simulate ( model ,   data )   The following code snippet simulates two traits where the random effects have cross covariances.  # a fake GRM  K   =   cor ( data )  I   =   eye ( npeople )  A   =   [ 0.2   - 0.1 ;   - 0.1   0.3 ]  B   =   [ 0.8   - 0.2 ;   - 0.2   0.7 ]  \u03bc   =   [ y1   ~   x1 + 0.2 ,   y2   ~   x3 + 0.1 log ( HDL ) + 0.1 ]  model   =   MixedEffectModel ( \u03bc ,   ( @vc   A   \u2297   K   +   B   \u2297   I ),   IdentityLink (),   NormalResponse ( 1.0 ))  simulate ( model ,   data )", 
            "title": "Simulate random effects"
        }, 
        {
            "location": "/model/model/", 
            "text": "Model Specifications\n\n\nThis section introduces types for specifying the simulation model. Other types mentioned in this section are introduced in detail in the following sections.\n\n\n\n\nSimulationModel\n\n\nSimulationModel\n is an abstract supertype for each specific simulation model.\n\n\n\n\nFixedEffectModel\n\n\nFixedEffectModel\n specifies simulations under the fixed-effect model. It\ns a subtype of \nSimulationModel\n.\n\n\nFixedEffectModel\n(\nfrml\n::\nFormulaType\n,\n\n                 \nlink\n::\nLinkFunctionType\n\n                 \ndist\n::\nResponseDistributionType\n)\n\n\n\n\n\n\nfrml\n can be a single formula, in which case, a single trait will be simulated, or an array of formulae, in which case, multiple traits will be simulated. Here, we use the \nFormula\n type in the \nDataFrames\n module.\n\n\nlink\n can be a single link function, in which case, all traits will be simulated under the same link function, or a vector of link functions, in which case, each trait will be simulated under its own link function.\n\n\ndist\n can be a single response distribution, in which case, all traits will have the same response distribution, or a vector of response distributions, in which case, each trait will have its own response distribution.\n\n\n\n\nRandomEffectModel\n\n\nRandomEffectModel\n specifies simulations under the random effect model. It\ns a subtype of \nSimulationModel\n.\n\n\nRandomEffectModel\n(\ntraits\n::\nTraitType\n,\n\n                  \nvc\n::\nVector\n{\nVarianceComponent\n},\n\n                  \nlink\n::\nLinkFunctionType\n,\n\n                  \nresp_dist\n::\nResponseDistributionType\n)\n\n\n\n\n\n\ntraits\n can be a single symbol, in which case, a single trait will be simulated, or a vector of symbols, in which case multiple traits will be simulated.\n\n\nvc\n is an array of variance components / cross covariances and the corresponding covariance matrices. See the section on the \nVarianceComponent\n type for more detail.\n\n\n\n\nMixedEffectModel\n\n\nMixedEffectModel\n is a type of specify simulations under a fixed-effect model. It\ns a subtype of \nSimulationModel\n.\n\n\nMixedEffectModel\n(\nformula\n::\nFormulaType\n,\n\n                 \nvc\n::\nVector\n{\nVarianceComponent\n},\n\n                 \nlink\n::\nLinkFunctionType\n,\n\n                 \nresp_dist\n::\nResponseDistributionType\n)\n\n\n\n\n\n\n\n\nVarianceComponent\n\n\nVarianceComponent\n(\nvar_comp\n::\nUnion\n{\nFloat64\n,\n \nVector\n{\nFloat64\n},\n \nMatrix\n{\nFloat64\n}}\n\n                  \ncov_mat\n::\nMatrix\n{\nFloat64\n})\n\n\n\n\n\n\nThe \nvar_comp\n parameter specifies the variance component or the covariance matrix to be simulated. If \nvar_comp\n is of type \nVector{Float64}\n, it will be interpreted as a diagonal covariance matrix with off-diagnal elements equal to 0.\n\n\n\n\noperator \u2297\n\n\nThe TraitSimulation module implements the \n\u2297\n operator to compute the Kronecker product between two matrices.\n\n\n\u2297\n(\nA\n,\n \nB\n)\n \n=\n \nkron\n(\nA\n,\nB\n)\n\n\n\n\n\n\n\n\nmacro @vc\n\n\nThe TraitSimulation module provides a macro \n@vc\n to simplify the specification of variance components. The following code lists some examples to specify the variance components in a simulation model. The terms in the expression to the right of \n@vc\n must be defined.\n\n\n# a fake GRM\n\n\nK\n \n=\n \ncor\n(\nsnp_data\n)\n\n\nI\n \n=\n \neye\n(\npeople\n)\n\n\nA\n \n=\n \n[\n0.2\n \n-\n0.1\n;\n \n-\n0.1\n \n0.3\n]\n\n\nB\n \n=\n \n[\n0.8\n \n-\n0.2\n;\n \n-\n0.2\n \n0.7\n]\n\n\n\n\u03a3\n \n=\n \n@vc\n \n0.2\nK\n \n+\n \n0.8\nI\n \n\n\u03a3\n \n=\n \n@vc\n \nA\n \n\u2297\n \nK\n \n+\n \nB\n \n\u2297\n \nI\n\n\n\n\n\n\n\n\nVarianceComponentType\n\n\nVarianceComponentType\n is a type alias to specify the variance component or covariance matrices.\n\n\ntypealias\n \nVarianceComponentType\n\n  \nUnion\n{\nFloat64\n,\n \nVector\n{\nFloat64\n},\n \nMatrix\n{\nFloat64\n}}\n\n\n\n\n\n\n\n\nFormulaType\n\n\nFormulaType\n is a type alias to specify a single formula or a vector of formulae.\n\n\n\n\nTraitType\n\n\nTraitType\n is a type alias to specify a single symbol or a vector of symbols.", 
            "title": "Model Specifications"
        }, 
        {
            "location": "/model/model/#model-specifications", 
            "text": "This section introduces types for specifying the simulation model. Other types mentioned in this section are introduced in detail in the following sections.", 
            "title": "Model Specifications"
        }, 
        {
            "location": "/model/model/#simulationmodel", 
            "text": "SimulationModel  is an abstract supertype for each specific simulation model.", 
            "title": "SimulationModel"
        }, 
        {
            "location": "/model/model/#fixedeffectmodel", 
            "text": "FixedEffectModel  specifies simulations under the fixed-effect model. It s a subtype of  SimulationModel .  FixedEffectModel ( frml :: FormulaType , \n                  link :: LinkFunctionType \n                  dist :: ResponseDistributionType )   frml  can be a single formula, in which case, a single trait will be simulated, or an array of formulae, in which case, multiple traits will be simulated. Here, we use the  Formula  type in the  DataFrames  module.  link  can be a single link function, in which case, all traits will be simulated under the same link function, or a vector of link functions, in which case, each trait will be simulated under its own link function.  dist  can be a single response distribution, in which case, all traits will have the same response distribution, or a vector of response distributions, in which case, each trait will have its own response distribution.", 
            "title": "FixedEffectModel"
        }, 
        {
            "location": "/model/model/#randomeffectmodel", 
            "text": "RandomEffectModel  specifies simulations under the random effect model. It s a subtype of  SimulationModel .  RandomEffectModel ( traits :: TraitType , \n                   vc :: Vector { VarianceComponent }, \n                   link :: LinkFunctionType , \n                   resp_dist :: ResponseDistributionType )   traits  can be a single symbol, in which case, a single trait will be simulated, or a vector of symbols, in which case multiple traits will be simulated.  vc  is an array of variance components / cross covariances and the corresponding covariance matrices. See the section on the  VarianceComponent  type for more detail.", 
            "title": "RandomEffectModel"
        }, 
        {
            "location": "/model/model/#mixedeffectmodel", 
            "text": "MixedEffectModel  is a type of specify simulations under a fixed-effect model. It s a subtype of  SimulationModel .  MixedEffectModel ( formula :: FormulaType , \n                  vc :: Vector { VarianceComponent }, \n                  link :: LinkFunctionType , \n                  resp_dist :: ResponseDistributionType )", 
            "title": "MixedEffectModel"
        }, 
        {
            "location": "/model/model/#variancecomponent", 
            "text": "VarianceComponent ( var_comp :: Union { Float64 ,   Vector { Float64 },   Matrix { Float64 }} \n                   cov_mat :: Matrix { Float64 })   The  var_comp  parameter specifies the variance component or the covariance matrix to be simulated. If  var_comp  is of type  Vector{Float64} , it will be interpreted as a diagonal covariance matrix with off-diagnal elements equal to 0.", 
            "title": "VarianceComponent"
        }, 
        {
            "location": "/model/model/#operator", 
            "text": "The TraitSimulation module implements the  \u2297  operator to compute the Kronecker product between two matrices.  \u2297 ( A ,   B )   =   kron ( A , B )", 
            "title": "operator \u2297"
        }, 
        {
            "location": "/model/model/#macro-vc", 
            "text": "The TraitSimulation module provides a macro  @vc  to simplify the specification of variance components. The following code lists some examples to specify the variance components in a simulation model. The terms in the expression to the right of  @vc  must be defined.  # a fake GRM  K   =   cor ( snp_data )  I   =   eye ( people )  A   =   [ 0.2   - 0.1 ;   - 0.1   0.3 ]  B   =   [ 0.8   - 0.2 ;   - 0.2   0.7 ]  \u03a3   =   @vc   0.2 K   +   0.8 I   \u03a3   =   @vc   A   \u2297   K   +   B   \u2297   I", 
            "title": "macro @vc"
        }, 
        {
            "location": "/model/model/#variancecomponenttype", 
            "text": "VarianceComponentType  is a type alias to specify the variance component or covariance matrices.  typealias   VarianceComponentType \n   Union { Float64 ,   Vector { Float64 },   Matrix { Float64 }}", 
            "title": "VarianceComponentType"
        }, 
        {
            "location": "/model/model/#formulatype", 
            "text": "FormulaType  is a type alias to specify a single formula or a vector of formulae.", 
            "title": "FormulaType"
        }, 
        {
            "location": "/model/model/#traittype", 
            "text": "TraitType  is a type alias to specify a single symbol or a vector of symbols.", 
            "title": "TraitType"
        }, 
        {
            "location": "/generate/generate/", 
            "text": "Generate Simulations\n\n\nThis section introduces the \nsimulate\n function for simulating traits according to the specified model.\n\n\n\n\nsimulate\n\n\nsimulate\n(\nmodel\n::\nModel\n,\n \ndata_frame\n::\nDataFrame\n;\n \npattern\n::\nMissingPattern\n=\n1.0\n)\n\n\n\n\n\n\nThe \nsimulate\n function simulates traits according to the \nModel\n using data stored in the \nDataFrame\n. One can use the \npattern\n keyword to specify desired missing pattern. See the  section \nMissingPattern\n for details on supported missing patterns.\n\n\n\n\nInputDataType\n\n\nInputDataType\n is a type alias for different types of input data, which can be either a \nDataFrame\n or \nSnpArray{2}\n.\n\n\n\n\nMissingPattern\n\n\nMissingPattern\n is a type alias for different ways to specify missing entries of simulated trait(s). Entries marked as missing have the value \nNA\n.\n\n\ntypealias\n \nMissingPattern\n\n  \nUnion\n{\nFloat64\n,\n \nVector\n{\nBool\n},\n \nMatrix\n{\nBool\n},\n \nBitArray\n{\n1\n},\n \nBitArray\n{\n2\n},\n\n        \nVector\n{\nInt64\n},\n \nVector\n{\nVector\n{\nInt64\n}},\n \nUnitRange\n{\nInt64\n},\n\n        \nVector\n{\nUnitRange\n{\nInt64\n}},\n \nStepRange\n{\nInt64\n,\n \nInt64\n},\n\n        \nVector\n{\nStepRange\n{\nInt64\n,\nInt64\n}}}\n\n\n\n\n\n\n\n\nFloat64\n\n\nMissing pattern specified as float will be interpreted as missing rate. For simulations involving multiple traits, the same missing rate is applied across all traits.\n\n\n\n\nVector{Bool}, BitArray{1}, or Vector{Int64}\n\n\nMissing pattern specified as \nVector{Bool}\n, \nBitArray{1}\n or \nVector{Int64}\n will be interpreted as an index set containing indices of the missing entries. For simulations involving multiple traits, the same missing pattern is applied across all traits.\n\n\n\n\nMatrix{Bool}, BitArray{2}, or Vector{Vector{Int64}}\n\n\nMissing pattern specified as \nMatrix{Bool}\n or \nBitArray{2}\n  with dimension $people \\times traits$ or \nVector{Vector{Int64}}\n with length $traits$ will be interpreted as index sets containing indices of the missing entries. This allows for different traits to have different index sets for missing entries.\n\n\n\n\nUnitRange{Int64} or StepRange{Int64, Int64}\n\n\nMissing pattern spcified as \nUnitRange{Int64}\n or \nStepRange{Int64, Int64}\n can be used to specify a range of missing entries. For simulations involving multiple traits, the same missing pattern will be applied across all traits.\n\n\n\n\nVector{UnitRange{Int64}} or Vector{StepRange{Int64, Int64}}\n\n\nMissing pattern specified as \nVector{UnitRange{Int64}}\n or \nVector{StepRange{Int64, Int64}}\n can be used to specify different ranges of missing entries for different traits for simulations involing multiple traits.", 
            "title": "Generate Simulations"
        }, 
        {
            "location": "/generate/generate/#generate-simulations", 
            "text": "This section introduces the  simulate  function for simulating traits according to the specified model.", 
            "title": "Generate Simulations"
        }, 
        {
            "location": "/generate/generate/#simulate", 
            "text": "simulate ( model :: Model ,   data_frame :: DataFrame ;   pattern :: MissingPattern = 1.0 )   The  simulate  function simulates traits according to the  Model  using data stored in the  DataFrame . One can use the  pattern  keyword to specify desired missing pattern. See the  section  MissingPattern  for details on supported missing patterns.", 
            "title": "simulate"
        }, 
        {
            "location": "/generate/generate/#inputdatatype", 
            "text": "InputDataType  is a type alias for different types of input data, which can be either a  DataFrame  or  SnpArray{2} .", 
            "title": "InputDataType"
        }, 
        {
            "location": "/generate/generate/#missingpattern", 
            "text": "MissingPattern  is a type alias for different ways to specify missing entries of simulated trait(s). Entries marked as missing have the value  NA .  typealias   MissingPattern \n   Union { Float64 ,   Vector { Bool },   Matrix { Bool },   BitArray { 1 },   BitArray { 2 }, \n         Vector { Int64 },   Vector { Vector { Int64 }},   UnitRange { Int64 }, \n         Vector { UnitRange { Int64 }},   StepRange { Int64 ,   Int64 }, \n         Vector { StepRange { Int64 , Int64 }}}", 
            "title": "MissingPattern"
        }, 
        {
            "location": "/generate/generate/#float64", 
            "text": "Missing pattern specified as float will be interpreted as missing rate. For simulations involving multiple traits, the same missing rate is applied across all traits.", 
            "title": "Float64"
        }, 
        {
            "location": "/generate/generate/#vectorbool-bitarray1-or-vectorint64", 
            "text": "Missing pattern specified as  Vector{Bool} ,  BitArray{1}  or  Vector{Int64}  will be interpreted as an index set containing indices of the missing entries. For simulations involving multiple traits, the same missing pattern is applied across all traits.", 
            "title": "Vector{Bool}, BitArray{1}, or Vector{Int64}"
        }, 
        {
            "location": "/generate/generate/#matrixbool-bitarray2-or-vectorvectorint64", 
            "text": "Missing pattern specified as  Matrix{Bool}  or  BitArray{2}   with dimension $people \\times traits$ or  Vector{Vector{Int64}}  with length $traits$ will be interpreted as index sets containing indices of the missing entries. This allows for different traits to have different index sets for missing entries.", 
            "title": "Matrix{Bool}, BitArray{2}, or Vector{Vector{Int64}}"
        }, 
        {
            "location": "/generate/generate/#unitrangeint64-or-steprangeint64-int64", 
            "text": "Missing pattern spcified as  UnitRange{Int64}  or  StepRange{Int64, Int64}  can be used to specify a range of missing entries. For simulations involving multiple traits, the same missing pattern will be applied across all traits.", 
            "title": "UnitRange{Int64} or StepRange{Int64, Int64}"
        }, 
        {
            "location": "/generate/generate/#vectorunitrangeint64-or-vectorsteprangeint64-int64", 
            "text": "Missing pattern specified as  Vector{UnitRange{Int64}}  or  Vector{StepRange{Int64, Int64}}  can be used to specify different ranges of missing entries for different traits for simulations involing multiple traits.", 
            "title": "Vector{UnitRange{Int64}} or Vector{StepRange{Int64, Int64}}"
        }, 
        {
            "location": "/link/link/", 
            "text": "Link Functions\n\n\nThis section lists the link function types supported by the TraitSimulation module.\n\n\n\n\nLinkFunction\n\n\nLinkFunction\n is an abstract type. It\ns the super type of each specific link function type listed below. All sub types of \nLinkFunction\n have constructors of the form \n[name of the link]()\n, and contain \nlink_inv::Function\n as their member variables. For example the constructor for identity link function type is \nIdentityLink()\n, and its \nlink_inv\n member variable is the function \nf(x) = x\n.\n\n\n\n\nLinkFunctionType\n\n\nLinkFunctionType\n is a type alias for a single link function or a vector of link functions.\n\n\n\n\nCauchitLink\n\n\nImplements the Cauchit link \ng(\\mu) = \\text{arctan}(\\mu)/\\pi+1/2\n, which has inverse \ng^{-1}(\\eta) = \\text{tan}[(\\eta-1/2)\\pi]\n.\n\n\n\n\nCloglogLink\n\n\nImplements the complementary log log link, \ng(\\mu) = \\log(-\\log(1-\\mu))\n which has invserse \ng^{-1}(\\eta) = 1 - \\exp(-\\exp(\\eta))\n.\n\n\n\n\nIdentityLink\n\n\nImplements the identity link \ng(\\mu) = \\mu\n, which has inverse \ng^{-1}(\\eta) = \\eta\n\n\n\n\n\n\nInverseLink\n\n\nImplements the inverse link \ng(\\mu) = 1/\\mu\n, which has inverse \ng^{-1}(\\eta) = 1/\\eta\n\n\n\n\n\n\nLogitLink\n\n\nImplements the logit link \ng(\\mu) = \\log(\\mu / (1-\\mu))\n, which has inverse \ng^{-1}(\\eta) = 1 / (1+\\exp(-\\eta))\n.\n\n\n\n\nProbitLink\n\n\nImplements the probit link \ng(\\mu) = \\Phi^{-1}(\\mu)\n, which has inverse \ng^{-1}(\\eta) = \\Phi(\\eta)\n\n\n\n\n\n\nSqrtLink\n\n\nImplements the square root link \ng(\\mu) = \\sqrt{\\mu}\n, which has inverse \ng^{-1}(\\eta) = \\eta^2\n.\n\n\n\n\nLogLink\n\n\nImplements the log link \ng(\\mu) = \\log(\\mu)\n, which has inverse \ng^{-1}(\\eta) = \\exp(\\eta)\n.", 
            "title": "Link Functions"
        }, 
        {
            "location": "/link/link/#link-functions", 
            "text": "This section lists the link function types supported by the TraitSimulation module.", 
            "title": "Link Functions"
        }, 
        {
            "location": "/link/link/#linkfunction", 
            "text": "LinkFunction  is an abstract type. It s the super type of each specific link function type listed below. All sub types of  LinkFunction  have constructors of the form  [name of the link]() , and contain  link_inv::Function  as their member variables. For example the constructor for identity link function type is  IdentityLink() , and its  link_inv  member variable is the function  f(x) = x .", 
            "title": "LinkFunction"
        }, 
        {
            "location": "/link/link/#linkfunctiontype", 
            "text": "LinkFunctionType  is a type alias for a single link function or a vector of link functions.", 
            "title": "LinkFunctionType"
        }, 
        {
            "location": "/link/link/#cauchitlink", 
            "text": "Implements the Cauchit link  g(\\mu) = \\text{arctan}(\\mu)/\\pi+1/2 , which has inverse  g^{-1}(\\eta) = \\text{tan}[(\\eta-1/2)\\pi] .", 
            "title": "CauchitLink"
        }, 
        {
            "location": "/link/link/#clogloglink", 
            "text": "Implements the complementary log log link,  g(\\mu) = \\log(-\\log(1-\\mu))  which has invserse  g^{-1}(\\eta) = 1 - \\exp(-\\exp(\\eta)) .", 
            "title": "CloglogLink"
        }, 
        {
            "location": "/link/link/#identitylink", 
            "text": "Implements the identity link  g(\\mu) = \\mu , which has inverse  g^{-1}(\\eta) = \\eta", 
            "title": "IdentityLink"
        }, 
        {
            "location": "/link/link/#inverselink", 
            "text": "Implements the inverse link  g(\\mu) = 1/\\mu , which has inverse  g^{-1}(\\eta) = 1/\\eta", 
            "title": "InverseLink"
        }, 
        {
            "location": "/link/link/#logitlink", 
            "text": "Implements the logit link  g(\\mu) = \\log(\\mu / (1-\\mu)) , which has inverse  g^{-1}(\\eta) = 1 / (1+\\exp(-\\eta)) .", 
            "title": "LogitLink"
        }, 
        {
            "location": "/link/link/#probitlink", 
            "text": "Implements the probit link  g(\\mu) = \\Phi^{-1}(\\mu) , which has inverse  g^{-1}(\\eta) = \\Phi(\\eta)", 
            "title": "ProbitLink"
        }, 
        {
            "location": "/link/link/#sqrtlink", 
            "text": "Implements the square root link  g(\\mu) = \\sqrt{\\mu} , which has inverse  g^{-1}(\\eta) = \\eta^2 .", 
            "title": "SqrtLink"
        }, 
        {
            "location": "/link/link/#loglink", 
            "text": "Implements the log link  g(\\mu) = \\log(\\mu) , which has inverse  g^{-1}(\\eta) = \\exp(\\eta) .", 
            "title": "LogLink"
        }, 
        {
            "location": "/dist/dist/", 
            "text": "Response Distribution\n\n\nThis sections lists the response distributions supported by the TraitSimulation module.\n\n\n\n\nResponseDistribution\n\n\nResponseDistribution\n is an abstract type. It\ns the super type of each specific response distribution listed below. All sub types of \nResponseDistribution\n have constructors of the form \n[distribution type](...)\n. Parameter(s) passed to the constructor of each ResponseDistribution are specific to the type of the distribution.\n\n\n\n\nResponseDistributionType\n\n\nResponseDistributionType\n is a type alias for a single response distribution or a vector of response distributions.\n\n\n\n\nNormalResponse\n\n\nConstructs a normal response type, through \nNormalResponse(\u03c3)\n, where \n\u03c3\n is the standard deviation of the normal distribution.\n\n\n\n\nBinomialResponse\n\n\nConstructs a binomial response type, through \nBinomialResponse(n)\n, where \nn\n is the number of trials in the binomial distribution.\n\n\n\n\nTResponse\n\n\nConstructs a T response type, through \nTResponse(\u03bd)\n,  where \n\u03bd\n is the degrees of freedom. The simulated trait is a shifted (by $\\mu$) version of T response.\n\n\n\n\nGammaResponse\n\n\nConstructs a Gamma response type, through \nGammaResponse(\u03b1)\n, where \n\u03b1\n is the shape parameter.\n\n\n\n\nInverseGaussianResponse\n\n\nConstructs an inverse Gaussian response, through \nInverseGaussianResponse(\u03bb)\n where \n\u03bb\n is the shape parameter.\n\n\n\n\nPoissonResponse\n\n\nConstructs a Poisson response, through \nPoisson()\n.\n\n\n\n\nExponentialResponse\n\n\nConstructs an exponential response, through \nExponentialResponse()\n.\n\n\n\n\nBernoulliResponse\n\n\nConstructs a Bernoulli response, through \nBernoulli()\n.\n\n\n\n\nDirectResponse\n\n\nDirectly output the mean, without imposing any distribution.", 
            "title": "Response Distributions"
        }, 
        {
            "location": "/dist/dist/#response-distribution", 
            "text": "This sections lists the response distributions supported by the TraitSimulation module.", 
            "title": "Response Distribution"
        }, 
        {
            "location": "/dist/dist/#responsedistribution", 
            "text": "ResponseDistribution  is an abstract type. It s the super type of each specific response distribution listed below. All sub types of  ResponseDistribution  have constructors of the form  [distribution type](...) . Parameter(s) passed to the constructor of each ResponseDistribution are specific to the type of the distribution.", 
            "title": "ResponseDistribution"
        }, 
        {
            "location": "/dist/dist/#responsedistributiontype", 
            "text": "ResponseDistributionType  is a type alias for a single response distribution or a vector of response distributions.", 
            "title": "ResponseDistributionType"
        }, 
        {
            "location": "/dist/dist/#normalresponse", 
            "text": "Constructs a normal response type, through  NormalResponse(\u03c3) , where  \u03c3  is the standard deviation of the normal distribution.", 
            "title": "NormalResponse"
        }, 
        {
            "location": "/dist/dist/#binomialresponse", 
            "text": "Constructs a binomial response type, through  BinomialResponse(n) , where  n  is the number of trials in the binomial distribution.", 
            "title": "BinomialResponse"
        }, 
        {
            "location": "/dist/dist/#tresponse", 
            "text": "Constructs a T response type, through  TResponse(\u03bd) ,  where  \u03bd  is the degrees of freedom. The simulated trait is a shifted (by $\\mu$) version of T response.", 
            "title": "TResponse"
        }, 
        {
            "location": "/dist/dist/#gammaresponse", 
            "text": "Constructs a Gamma response type, through  GammaResponse(\u03b1) , where  \u03b1  is the shape parameter.", 
            "title": "GammaResponse"
        }, 
        {
            "location": "/dist/dist/#inversegaussianresponse", 
            "text": "Constructs an inverse Gaussian response, through  InverseGaussianResponse(\u03bb)  where  \u03bb  is the shape parameter.", 
            "title": "InverseGaussianResponse"
        }, 
        {
            "location": "/dist/dist/#poissonresponse", 
            "text": "Constructs a Poisson response, through  Poisson() .", 
            "title": "PoissonResponse"
        }, 
        {
            "location": "/dist/dist/#exponentialresponse", 
            "text": "Constructs an exponential response, through  ExponentialResponse() .", 
            "title": "ExponentialResponse"
        }, 
        {
            "location": "/dist/dist/#bernoulliresponse", 
            "text": "Constructs a Bernoulli response, through  Bernoulli() .", 
            "title": "BernoulliResponse"
        }, 
        {
            "location": "/dist/dist/#directresponse", 
            "text": "Directly output the mean, without imposing any distribution.", 
            "title": "DirectResponse"
        }
    ]
}